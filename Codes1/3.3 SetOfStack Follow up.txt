package kql.test.practise;

//1. sometimes type the wrong word.

import java.util.ArrayList;

/* Instants: 
* stacks: the set of stacks. stacks are consisted of several substack
* idArr: location at ArrayList<ArrayList<Integer>>
* idStk: location at sub stack
* item: return the number at index, popAt()
* 
* Methods: 
* 
* popAt(stacks, index):	return the item located at index
* shift(stacks):			shift between substack
* shiftHelp(stacks): 		shift within substack
*/


public class SetOfStacks {
	//global variables of class can be passed among the method, but the local variables can not be passed among the methods
	int subSize = 0;
	int idArr = 0;		
	int idStk = 0;

	public SetOfStacks(int s) { // constructor
		subSize = s;
	}

	// -----------------------
	public int popAt(ArrayList<ArrayList<Integer>> stacks, int index) {
		if (stacks.isEmpty()
				|| index < 0
				|| index > (subSize * (stacks.size() - 1) + stacks.get(
						stacks.size() - 1).size())) {
			throw new IllegalArgumentException(
					"empty or input index is illegal.");
		}
		int size = stacks.size();
		idArr = index / subSize;
		idStk = index % subSize;
		ArrayList<Integer> subStack = stacks.get(idArr);
		int item = subStack.get(idStk);

		if (index == size * subSize - 1) {  
			subStack.remove(idStk);
			return item;
		}
		// shift... more code....
		shift(stacks);
		return item;
	}

	// ------------------------
	public void shift(ArrayList<ArrayList<Integer>> stacks) {
		// method(int idArr, int idStk) idStk will not be changed unless we
		// operate idStk++, if method use and another method1 to increase idStk,
		// idStk will not be changed
		ArrayList<Integer> stack = stacks.get(idArr);
		int size = stacks.size();

		// if the item is located in the last stack of the set of stacks, so
		// remove the last element to complete the shift, else continue to shift
		// until to the last stack of the set of stacks
		while (idArr <= size - 1 && size > 0) {
			if (idArr == size - 1) { // the idArr located in the last stack of
										// the set of stacks
				// shiftHelp(stacks);
				stack = stacks.get(idArr); // get the last stack in the set of
											// stacks
				int lastSize = stack.size(); // lastSize is the size of last
												// stack in the stacks
				while (idStk < lastSize - 1) { // ..........................
					stack.set(idStk, stack.get(idStk + 1));
					idStk++;
				}
				stack.remove(idStk);// ...........
				if (idStk == 0) {
					stacks.remove(idArr); // should pay more attention to the boundary condition, if substack is empty, we should remove substack from the stacks
					idArr--;
					size--;
				}
			} else {
				stack = stacks.get(idArr);
				ArrayList<Integer> stackNext = stacks.get(idArr + 1);
				shiftHelp(stacks);
				stack.set(idStk, stackNext.get(0));
				idStk = 0;
				// shiftHelp(stacks, idArr + 1, 0);
			}
			idArr++;
		}// end while
	}

	public void shiftHelp(ArrayList<ArrayList<Integer>> stacks) {
		ArrayList<Integer> stack = stacks.get(idArr);
		while (idStk < subSize - 1) {
			stack.set(idStk, stack.get(idStk + 1));
			idStk++;
		} // at this time: idStk == subSize-1
	}


//-----------------for test---------------------------------
	public static void main(String[] args) {
		ArrayList<ArrayList<Integer>> stacks = new ArrayList<ArrayList<Integer>>();
		ArrayList<Integer> stk1 = new ArrayList<Integer>();
		ArrayList<Integer> stk2 = new ArrayList<Integer>();
		ArrayList<Integer> stk3 = new ArrayList<Integer>();
		stacks.add(stk1);
		stacks.add(stk2);
		stacks.add(stk3);
		stk1.add(0);
		stk1.add(1);
		stk1.add(2);
		stk1.add(3);
		stk1.add(4);
		stk2.add(5);
		stk2.add(6);
		stk2.add(7);
		stk2.add(8);
		stk2.add(9);
		stk3.add(10);
		stk3.add(11);

		int subSize = 5;
		SetOfStacks ss = new SetOfStacks(subSize);

		int count = 12;
		while (count != 0) {
			int p0 = ss.popAt(stacks, 0);
			System.out.println(" " + p0 + "; ");
			count--;
		}
	}
} // end class
