package kql.test.practise;

/* This is solution from CC, I need to code it again without the solution.
 * Finally, I understand what this code is doing!
 * 
 * >>actionQueue.poll(): describe its function
 * >>startWord.toUpperCase(): transform the string into the capital letters string. e.g. house-->HOUSE
 * 
 * >> It uses the HashMap not Hashtable, since we can put null in the HashMap, but not Hashtable!! it is important
 * 
 * 18.10 Given two words of equal length that are in a dictionary, write a method to transform
 * one word into another word by changing only one letter at a time. The new word you get in 
 * each step must be in the dictionary.
 * 
 */

import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

public class TransformWords {

	LinkedList<String> transform(String startWord, String stopWord,
			Set<String> dictionary) {
		startWord = startWord.toUpperCase(); // .touppercase??
		stopWord = stopWord.toUpperCase(); // transform to capital characters
		Queue<String> actionQueue = new LinkedList<String>();
		Set<String> visitedSet = new HashSet<String>(); // hashset
		Map<String, String> backtrackMap = new TreeMap<String, String>(); // treemap

		actionQueue.add(startWord);
		visitedSet.add(startWord);

		while (!actionQueue.isEmpty()) {
			String w = actionQueue.poll();
			/* for each possible word v from w with one edit operation */
			for (String v : getOneEditWords(w)) {
				if (v.equals(stopWord)) {
					LinkedList<String> list = new LinkedList<String>();
					list.add(v);
					while (w != null) {
						list.add(0, w);
						w = backtrackMap.get(w);
					}
					return list;
				}
				if (dictionary.contains(v)) {
					if (!visitedSet.contains(v)) {
						actionQueue.add(v);
						visitedSet.add(v);
						backtrackMap.put(v, w);
					}
				}
			}
		}
		return null;
	} // end method
		// --------------------------------------------------

	Set<String> getOneEditWords(String word) { // change one letter in the word
		Set<String> words = new TreeSet<String>(); // tree set
		for (int i = 0; i < word.length(); i++) {
			char[] wordArray = word.toCharArray();
			for (char c = 'A'; c <= 'Z'; c++) {
				if (c != word.charAt(i)) {
					wordArray[i] = c;
					words.add(new String(wordArray));
				}
			}
		}
		return words;
	}

	// ---------------------------------------------------
	public static void main(String[] args) {
		String startWord = "damp";
		String stopWord = "like";
		Set<String> dictionary = new HashSet<String>();
		dictionary.add("DAMP");
		dictionary.add("APPLE");
		dictionary.add("DEEP");
		dictionary.add("LIGHT");
		dictionary.add("LAMP");
		dictionary.add("PIPE");
		dictionary.add("LIKE");
		dictionary.add("LIMP");
		dictionary.add("LIME");
		dictionary.add("DESPERATE");
		dictionary.add("HOUSE");

		TransformWords t = new TransformWords();
		LinkedList<String> result = t
				.transform(startWord, stopWord, dictionary);
		for (String s : result) {
			System.out.print("{" + s + "} ");
		}
	}
}
