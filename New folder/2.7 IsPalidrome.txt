
//Implement a function to check if a linked list is a palindrome.


/*-----PartI I use double linked list to implement the function----------------------------------------------------------------------------------------------------*/
package kql.test.practise;


// The first way, I used double linked list.. 
//9:37 PM 1/18/2014---10:08 PM 1/18/2014
/* Note: 
 * 	1. if ....else if... is very different from if..., if... 
 * 	2. A==B   is very different from   A.equals(B)
 * 	3. Since it is double linked list, pay more attention when you add new node to the linked list. You should set both pointers next and previous
 * 		i.e. A.next = B; B.previous = A;
 * 
 */

/*------------------------------------------------------------------*/
class DoubleLList {
	int data = 0;
	DoubleLList previous = null;
	DoubleLList next = null;

	public DoubleLList(int d) {
		data = d;
	}

	void appendToTail(int n) {
		DoubleLList end = new DoubleLList(n);
		DoubleLList current = this;
		while (current.next != null) {
			current = current.next;
		}
		current.next = end;
		end.previous = current;
	}
} // end class1
/*-------------------------------------------------------------------*/

public class IsPalidrome {

	// pointer: slow, fast
	// two case: odd and even

	boolean isPal(DoubleLList ll) {
		if (ll == null)
			return true;

		DoubleLList slow = ll;
		DoubleLList fast = ll;

		while (fast.next != null && fast.next.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
/*if ....else if... is very different from if..., if... */
		if (fast.next == null) { // it is odd 
			DoubleLList mid = slow;
			slow = ll;
//			while (slow != mid) {
			while(!slow.equals(mid)){
				if (slow.data != fast.data) {
					return false;
				}
				slow = slow.next;
				fast = fast.previous;
			}
		} // end if

		else if (fast.next.next == null) { // it is even
			DoubleLList mid = slow;
			slow = ll;
			fast = fast.next;
//			while (slow != mid) {
			while(!slow.equals(mid)){
				if (slow.data != fast.data) {
					return false;
				}
				slow = slow.next;
				fast = fast.previous;
			}
			if (slow.data != fast.data) { // when slow == mid
				return false;
			}
		}

		return true;
	} // end method
//---for test---------------------------
	public static void main(String[] args) {
		DoubleLList ll = new DoubleLList(1);
		ll.appendToTail(2);
		ll.appendToTail(3);
		ll.appendToTail(4);
//		ll.appendToTail(9);
		
		ll.appendToTail(4);
		
		ll.appendToTail(4);
		ll.appendToTail(3);
		ll.appendToTail(2);
		ll.appendToTail(1);
//		ll.appendToTail(0);
		
//		DoubleLList ll2 = new DoubleLList(0);
		
		IsPalidrome ip = new IsPalidrome();
		boolean result = ip.isPal(ll);
		System.out.println("result: "+result);		
		
	}

} // end class2





/*-----------PartII I use a stack to implement the function, single linked list ------------------------------------------------------*/

//8:10 PM 1/19/2014
//coding..........
//8:47 PM 1/19/2014
//Note: 9/2 = 4
//single linked list
/*
 * I used stack to store the variables which will be popped and compared
 */

package kql.test.practise;

import java.util.Stack;

class LList {

	int data = 0;
	LList next = null;

	public LList(int d) {
		data = d;
	}

	public void appendToTail(int n) {
		LList end = new LList(n);
		LList current = this;
		while (current.next != null) {
			current = current.next;
		}
		current.next = end;
	}
}// end class 1

/*-------------------------------------------------------*/
public class IsPalidrome {

	Stack<LList> stk = new Stack<LList>();

	boolean isPalidrome(LList ll) {
		if (ll == null)
			return true;
		LList slow = ll; // the slower pointer
		LList fast = ll; // the faster pointer
		LList mid = null; // used as a flag to mark the middle of the linked
							// list. If it is odd, mid marks the middle node, if
							// it is even, mid marks the (n/2)+1
		// to find the middle of the linked list
		while (fast.next != null && fast.next.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		if (fast.next == null) { // odd
			mid = slow;
			slow = slow.next;
		} else if (fast.next.next == null) { // even
			slow = slow.next;
			mid = slow;
		}
		// put each data of second half of the linked list into stack
		while (slow != null) {
			stk.push(slow);
			slow = slow.next;
		}
		slow = ll; // the pointer is back to the head of the linked list
		while (!slow.equals(mid)) {
			if (slow.data != stk.pop().data) {
				return false;
			}
			slow = slow.next;
		}
		return true;

	}

	// for test---------------------
	public static void main(String[] args) {
		// build a linked list for tests
		LList ll = new LList(2);
		ll.appendToTail(3);
		ll.appendToTail(4);
		ll.appendToTail(5);
		ll.appendToTail(6);

		ll.appendToTail(0);

		ll.appendToTail(6);
		ll.appendToTail(5);
		ll.appendToTail(4);
		ll.appendToTail(3);
		ll.appendToTail(2);
		// LList ll2 = null;
		IsPalidrome ip = new IsPalidrome();
		boolean result = ip.isPalidrome(ll);
		System.out.println("result: " + result);

	}

} // end class2
/*--------------------------------------------------------*/






