package kql.test.practise;

//tree
/*                30				
 *           /           \								
 *       15                 44							
 *      /  \              /    \ 						
 *   7      23         37       30						
 *  / \    /  \       /  \     /   \ 			
 * 2   9  19   27    33   40  47   61  		
 * ..........................................................
 /* Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. 
 * Avoid storing additional nodes in a data structure. NOTE: This is not necessarily a binary search tree.
 * 
 * Methods: 
 * firstAncestor(TreeNode root, TreeNode n1, TreeNode n2):	find the first common ancestor of n1 and n2 and return it. if not return null
 * search(TreeNode root, TreeNode n):	if n is in the tree root, return true, else return false.	
 */
public class FindFirstAncestor {

	// --if find it, return the node, else return null--
//------------------------------------------------------------------------------------------------------------------
	TreeNode firstAncestor(TreeNode root, TreeNode n1, TreeNode n2) {
		// boundary condition
		if ((search(root, n1) || search(root, n2)) == false) // n1 or n2 is not
																// in the tree
			return null;
		if (n1 == null) {
			return n2;
		}
		if (n2 == null) {
			return n1;
		}
		if (n1 == root || n2 == root) {
			return root;
		}
		// n1 and n2 is not root now
		boolean srch = search(n1, n2);
		if (srch == true) {
			return n1;
		} // n2 is in the subtree of n1.

		TreeNode current = n1;
		TreeNode parent = n1.parent;

		while (parent != null) {
			if (parent.equals(n2)) {
				return n2;
			}
			if (current == parent.left) {
				srch = search(parent.right, n2);
			} else if (current == parent.right) {
				srch = search(parent.left, n2);
			}
			if (srch == false) {
				current = parent;
				parent = parent.parent;
			} else if (srch == true) { // srch could be false or true
				return parent;
			}
		}
		return null;
	}// end method1
		// --search node, if find return true, else return false--------------

	boolean search(TreeNode root, TreeNode node) {
		if (root == null) {
			return false;
		}
		if (root.equals(node)) {
			return true;
		}

		boolean tp1 = search(root.left, node);
		boolean tp2 = search(root.right, node);
		boolean result = tp1 || tp2;
		return result;
		// return search(root.left, node) || search(root.left, node);
	}// end method2
//--------------------------------------------------------------------------------------------------------------
// --------------------for test--------------------------------------
	public static void main(String[] args) {
		FindFirstAncestor ffa = new FindFirstAncestor();
		// -------create a tree for test---------------
		TreeNode rootest = null;
		// first level
		TreeNode r = new TreeNode(30);
		// second level
		r.left = new TreeNode(15);
		r.right = new TreeNode(44);
		r.left.parent = r;
		r.right.parent = r;
		// third level
		r.left.left = new TreeNode(7);
		r.left.right = new TreeNode(23);
		r.left.left.parent = r.left;
		r.left.right.parent = r.left;
		// r.right.left = new TreeNode(37);
		r.right.right = new TreeNode(30);
		// r.right.left.parent = r.right;
		r.right.right.parent = r.right;
		// forth level
		r.left.left.left = new TreeNode(2);
		r.left.left.right = new TreeNode(9);
		r.left.left.left.parent = r.left.left;
		r.left.left.right.parent = r.left.left;
		r.left.right.left = new TreeNode(19);
		r.left.right.right = new TreeNode(27);
		r.left.right.left.parent = r.left.right;
		r.left.right.right.parent = r.left.right;
		// r.right.left.left = new TreeNode(33);
		// r.right.left.right = new TreeNode(40);
		// r.right.left.left.parent = r.right.left;
		// r.right.left.right.parent = r.right.left;
		r.right.right.left = new TreeNode(47);
		r.right.right.right = new TreeNode(61);
		r.right.right.left.parent = r.right.right;
		r.right.right.right.parent = r.right.right;
		// --------created tree end---------------------
		TreeNode n1 = r.left.right.right;
		TreeNode n2 = r.left;

		TreeNode ancestor = ffa.firstAncestor(r, n1, n2);
		System.out.println("The first common ancestor: " + ancestor.data);
	} // end main
} // end class

// ------------------------
class TreeNode {
	int data = 0;
	TreeNode parent = null;
	TreeNode left = null;
	TreeNode right = null;

	public TreeNode(int d) {
		data = d;
	}
} // end class

