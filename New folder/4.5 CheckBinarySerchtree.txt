package kql.test.practise;

// 4.5 Implement a function to check if a binary tree is a binary search
// tree
/*                30				
 *           /           \								
 *       15                 44							
 *      /  \              /    \ 						
 *   7      23         37       30						
 *  / \    /  \       /  \     /   \ 			
 * 2   9  19   27    33   40  47   61  		
 * ..........................................................
 * 
 * Methods:  very bad. should refer to the solution of the book.
 * isBinTree(TreeNode root):	root is the root of the tree. If it is binary search tree, return true, else return false
 * getPrevious(TreeNode node): 	get the previous node of the current node
 * getNext(TreeNode node):		get the next node of the current node
 *  
*/


public class IsBinarySearchTree {

	// if it is a binary tree return true, else return false
	boolean isBinTree(TreeNode root) {
		// boundary condition:
		if (root == null) {
			System.out.println("The root is null.");
			return true;
		}
		if(root.left== null && root.right ==null){
			return true;
		}

		TreeNode pre = getPrevious(root);
		TreeNode nxt = getNext(root);
		boolean rltl = false;
		boolean rltr = false;
		if (pre == null && nxt == null) {
			return true;
		}
		if (pre != null) {
			if (pre.data >= root.data) {
				return false;
			}
		}
		if (nxt != null) {
			if (root.data >= nxt.data) {
				return false;
			}
		}
		
		rltl = isBinTree(root.left);
		rltr = isBinTree(root.right);

		return (rltl && rltr);
	} // end method

	//------- get the previous node of the current node-------
	TreeNode getPrevious(TreeNode node) {
		if (node == null || node.left == null) {
			return null;
		}
		if (node.left.right == null) {
			return node.left;
		}
		if (node.left.right != null) {
			TreeNode current = node.left.right;
			while (current.right != null) {
				current = current.right;
			}
			return current.right;
		}
		return null;
	}

	//------- get the next node of current node--------
	TreeNode getNext(TreeNode node) {
		// boundary condition
		if (node == null || node.right == null) {
			return null;
		}
		if (node.right.left == null) {
			return node.right;
		}
		if (node.right.left != null) {
			TreeNode current = node.right;
			while (current.left != null) {
				current = current.left;
			}
			return current;
		}
		return null;
	}

	//------ for test-------
	public static void main(String[] args) {
		IsBinarySearchTree ibt = new IsBinarySearchTree();
		//------build a tree for test---------------------
		TreeNode rootest = null;
		TreeNode r = new TreeNode(30);
		r.left = new TreeNode(15);
		r.right = new TreeNode(44);
		r.left.left = new TreeNode(7);
		r.left.right = new TreeNode(23);
		r.right.left = new TreeNode(37);
//		r.right.right = new TreeNode(30);
		r.left.left.left = new TreeNode(2);
		r.left.left.right = new TreeNode(9);
		r.left.right.left = new TreeNode(19);
		r.left.right.right = new TreeNode(27);
		r.right.left.left = new TreeNode(33);
		r.right.left.right = new TreeNode(40);
//		r.right.right.left = new TreeNode(47);
//		r.right.right.right = new TreeNode(61);
		//----built tree end------------------------------
		boolean result = ibt.isBinTree(r);
		System.out.println(result);
	}

}// end class

class TreeNode {
	int data = 0;
	TreeNode left = null;
	TreeNode right = null;

	public TreeNode(int d) {
		data = d;
	}

}


/******************Jan 22.2014 I think this code is better and much clearer *********************************************/

package kql.test.practise;

//4.5 Implement a function to check if a binary tree is binary search tree.

class TreeNode {
	int data = 0;
	TreeNode left = null;
	TreeNode right = null;

	public TreeNode(int d) {
		data = d;
	}
} // end class

public class IsBSTree {

	boolean isBSTree(TreeNode root) {
		if (root == null)
			throw new IllegalArgumentException("emtpy tree  :(");
		return isBSTree(root, null);
	}

	boolean isBSTree(TreeNode rt, TreeNode parent) {
		if (rt == null)
			return true;
		TreeNode pre = null;
		TreeNode next = null;
		if (parent == null && rt != null) {
			pre = getPrev(rt);
			next = getNext(rt);
			if (pre != null && pre.data > rt.data) {
				return false;
			}
			if (next != null && next.data < rt.data) {
				return false;
			}
		}

		if (parent != null && rt != null) {
			if (rt == parent.right) {
				if (rt.left == null)
					;
				pre = parent;
			} else {
				pre = getPrev(rt);
			}

			if (rt == parent.left) {
				if (rt.right == null) {
					next = parent;
				} else {
					next = getNext(rt);
				}
			}

			if (pre != null && pre.data > rt.data) {
				return false;
			}
			if (next != null && next.data < rt.data) {
				return false;
			}
		}

		return isBSTree(rt.left, rt) && isBSTree(rt.right, rt);

	} // end method

	TreeNode getPrev(TreeNode n) { // if have not left child return null
		if (n == null)
			return null;
		if (n.left == null)
			return null;
		TreeNode parent = n;
		TreeNode curr = parent.left;
		while (curr != null) {
			parent = curr;
			curr = curr.right;
		}
		return parent;
	} // end method

	TreeNode getNext(TreeNode n) {
		if (n == null)
			return null;
		if (n.right == null)
			return null;
		TreeNode parent = n;
		TreeNode curr = parent.left;
		while (curr != null) {
			curr = curr.right;
		}
		return parent;
	} // end method
		// for test ........

	public static void main(String[] args) {
		// create a tree for test
//		TreeNode rt = null;
		TreeNode r = new TreeNode(30);
		r.left = new TreeNode(15);
		r.right = new TreeNode(44);
		r.left.left = new TreeNode(7);
		// r.left.right = new TreeNode(23);
		r.right.left = new TreeNode(37);
		r.right.right = new TreeNode(50);
		r.left.left.left = new TreeNode(2);
		r.left.left.right = new TreeNode(9);
		// r.left.right.left = new TreeNode(19);
		// r.left.right.right = new TreeNode(27);
		r.right.left.left = new TreeNode(33);
		r.right.left.right = new TreeNode(40);
		r.right.right.left = new TreeNode(47);
		r.right.right.right = new TreeNode(61);
		
		IsBSTree ibt = new IsBSTree();
		boolean result = ibt.isBSTree(r);
		System.out.println(result+" ");
	}
} // end class
/****************************************************************************/


















